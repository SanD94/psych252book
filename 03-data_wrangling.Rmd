# Data wrangling

In this chapter, we will learn how manipulate, read, and save data. 
<!-- I promised that we'll look at a more interesting data set this time. We are going to take a look at London Crime Data, 2008-2016.  -->
 
## Todo 

- dealing with factors `recode_factor()`
- recoding discrete data with `recode()`
- mention `count()` for discrete data
- mention `case_when()`? https://suzan.rbind.io/2018/02/dplyr-tutorial-2/
- how to deal with NAs (e.g. `na.omit()`)
- link to the style guide here (http://style.tidyverse.org/index.html) and try to adhere to it myself

- data.frames as the 
- tidy data format 
- each row is one observation 
- [UK police data](https://data.police.uk/)
- [specific data set that we'll be using](https://data.gov.uk/dataset/994da1a8-6360-43f5-b32f-f9843d189136/crime-rates-by-london-borough)
- [geocomputation in R](https://geocompr.robinlovelace.net/) --> excellent resource

```{r, echo=FALSE, message=FALSE, include=FALSE}
library("knitr")
library("tidyverse")
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>")
```


## Setting up RStudio 

```{r pref-general, echo=FALSE, fig.cap="General preferences."}
  include_graphics("figures/screenshots/r_preferences_general.png")
```

__Make sure that__: 

- Restore .RData into workspace at startup is _unselected_ 
- Save workspace to .RData on exit is set to _Never_

```{r pref-code, echo=FALSE, fig.cap="Code window preferences."}
  include_graphics("figures/screenshots/r_preferences_code.png")
```

__Make sure that__: 

- Soft-wrap R source files is _selected_

This way you don't have to scroll horizontally. At the same time, avoid writing long single lines of code. For example, instead of writing code like so: 
```{r, eval=FALSE}
ggplot(data = diamonds, aes(x = cut, y = price))+
  stat_summary(fun.y = "mean", geom = "bar", color = "black", fill = "lightblue", width = 0.85)+ 
  stat_summary(fun.data = "mean_cl_boot", geom = "linerange", size = 1.5)+ 
  labs(title = "Price as a function of quality of cut", subtitle = "Note: The price is in US dollars", tag = "A", x = "Quality of the cut", y = "Price")
```

You may want to write it this way instead: 

```{r, eval=FALSE}
ggplot(data = diamonds, aes(x = cut, y = price))+
  # display the means
  stat_summary(fun.y = "mean",
               geom = "bar",
               color = "black",
               fill = "lightblue",
               width = 0.85)+ 
  # display the error bars
  stat_summary(fun.data = "mean_cl_boot",
               geom = "linerange", 
               size = 1.5)+ 
  # change labels 
  labs(
    title = "Price as a function of quality of cut", 
    subtitle = "Note: The price is in US dollars", # we might want to change this later
    tag = "A",
    x = "Quality of the cut", 
    y = "Price")
```

This makes it much easier to see what's going on, and you can easily add comments to individual lines of code. 

RStudio makes it easy to write nice code. It figures out where to put the next line of code when you press `ENTER`. And if things ever get messy, just select the code of interest and hit `cmd+I` to re-indent the code. 

Here are some more resources with tips for how to write nice code in R: 
- [Advanced R style guide](http://adv-r.had.co.nz/Style.html)

## Some R basics 

To test your knowledge of the R basics, I recommend taking the free interactive tutorial on datacamp: [Introduction to R](https://www.datacamp.com/courses/free-introduction-to-r). Here, I will just give a very quick overview of some of the basics. 


Let's start again by loading the `tidyverse` R package. If you don't have one of these packages yet, make sure to install it via running `install.packages("packagename")` in your console. 

```{r}
library("tidyverse")
```

### Getting help 

There are three simple ways to get help in R. You can either put a `?` in front of the function you'd like to learn more about, or use the `help()` function.

```{r, echo=FALSE}
?print 
help("print")
```

> __Tip__: To see the help file, hover over a function (or dataset) with the mouse (or select the text) and then press `F1`.

I recommend using `F1` to get to help files -- it's the fastest way! 

R help files can sometimes look a little cryptic. Most R help files have the following sections (copied from [here](https://www.dummies.com/programming/r/r-for-dummies-cheat-sheet/)): 

---

__Title__: A one-sentence overview of the function.

__Description__: An introduction to the high-level objectives of the function, typically about one paragraph long.

__Usage__: A description of the syntax of the function (in other words, how the function is called). This is where you find all the arguments that you can supply to the function, as well as any default values of these arguments.

__Arguments__: A description of each argument. Usually this includes a specification of the class (for example, character, numeric, list, and so on). This section is an important one to understand, because arguments are frequently a cause of errors in R.

__Details__: Extended details about how the function works, provides longer descriptions of the various ways to call the function (if applicable), and a longer discussion of the arguments.

__Value__: A description of the class of the value returned by the function.

__See also__: Links to other relevant functions. In most of the R editors, you can click these links to read the Help files for these functions.

__Examples__: Worked examples of real R code that you can paste into your console and run.

---

Here is the help file for the `print()` function: 

```{r print-function, echo=FALSE, fig.cap="Help file for the print() function."}
  include_graphics("figures/screenshots/help_print.png")
```

### Modes 

Variables in R can have different modes. Table shows the most common ones. 


```{r}
name = c("numeric", "character", "logical", 'not available')
example = c(
  "`1`, `3`, `48`",
  "`'Steve'`, `'a'`, `'78'`",
  "`TRUE`, `FALSE`",
  "`NA`")
kable(x = tibble(name, example), 
      caption = "Most commonly used variable modes in R.", 
      align = c("r", "l"),
      booktabs = TRUE)
```

For characters you can either use `"` or `'`. R has a number of functions to convert a variable from one mode to another. `NA` is used for missing values.

```{r}
tmp1 = '1' #we start with a character
str(tmp1) 

tmp2 = as.numeric(tmp1) #turn it into a numeric
str(tmp2) 

tmp3 = as.factor(tmp2) #turn that into a factor
str(tmp3)

tmp4 = as.character(tmp3) #and go full cycle by turning it back into a character
str(tmp4)

identical(tmp1, tmp4) #checks whether tmp1 and tmp4 are the same

```

The `str()` function displays the structure of an R object. Here, it shows us what mode the variable is. 

### Data types

R has a number of different data types. Table \@ref(tab:types) shows the ones you're most likely to come across (taken from [this source](https://www.statmethods.net/input/datatypes.html)): 


```{r types, echo=FALSE}
name = c("vector", "factor", "matrix", "array", "data frame", "list") 
description = c(
  "list of values with of the same variable mode",
  "for ordinal variables",
  "2D data structure",
  "same as matrix for higher dimensional data",
  "similar to matrix but with column names",
  "flexible type that can contain different other variable types"
  )
kable(x = tibble(name, description), 
      caption = "Most commonly used variable types in R.", 
      align = c("r", "l"),
      booktabs = TRUE)
```

#### Vectors 

We build vectors using the concatenate function `c()`, and we use `[]` to access one or more elements of a vector.  

```{r}
numbers = c(1, 4, 5) #make a vector
numbers[2] #access the second element 
numbers[1:2] #access the first two elements
numbers[c(1, 3)] #access the first and last element

```

In R (unlike in Python for example), 1 refers to the first element of a vector (or list). 

#### Matrix 

We build a matrix using the `matrix()` function, and we use `[]` to access its elements. 

```{r}
matrix = matrix(data = c(1, 2, 3, 4, 5, 6), nrow = 3, ncol = 2)
matrix #the full matrix
matrix[1, 2] #element in row 1, column 2
matrix[1, ] #all elements in the first row 
matrix[ , 1] #all elements in the first column 
matrix[-1 , ] #a matrix which excludes the first row
```

Note how we use an empty placeholder to indicate that we want to select all the values in a row or column, and `-` to indicate that we want to remove something.

#### Array 

Arrays work the same was as matrices with data of more than two dimensions. 

#### Data frame 

```{r}
df = data_frame(participant_id = c(1, 2, 3),
                participant_name = c("Leia", "Luke", "Darth")) #make the data frame 

df # the complete data frame
df[1, 2] #a single element using numbers 

df$participant_id #all participants 
df[["participant_id"]] #same as before but using [[]] instead of $

df$participant_name[2] #name of the second participant
df[["participant_name"]][2] #same as above
```

We'll use data frames a lot. Data frames are like a matrix with column names. Data frames are also more general than matrices in that different columns can have different modes. For example, one column might be a character, another one numeric, and another one a factor. You may sometimes also see a `tibble` instead of a data frame. A `tibble` is almost the same asa  data frame but it has better defaults for formatting output in the console (more information on tibbles is [here](http://r4ds.had.co.nz/tibbles.html)). 


<!-- Mention that one can have lists inside data frames here? -->

#### Lists 

```{r}
l.mixed = list(number = 1, 
               character = "2", 
               factor = factor(3), 
               matrix = matrix(1:4, ncol = 2),
               df = data_frame(x = c(1, 2), y = c(3, 4)))
l.mixed
l.mixed$character
l.mixed[['character']]
l.mixed[[2]] #three different ways of accessing a list
```
Lists are a very flexible data format. You can put almost anything in a list. You can then access the elements of a list either using 

tibble; same as data frame with better defaults for formatting output in the console; more information on [tibbles](http://r4ds.had.co.nz/tibbles.html)

### Operators

Table \@ref(tab:operators) shows the comparison operators that result in logical outputs. 

```{r operators, echo=FALSE}
operators = c("`==`", "`!=`", "`>, <`", "`>=, <=`", "`&, |, !`", "`%in%`")
explanation = c("equal to", "not equal to", "greater/less than", "greater/less than or equal", "logical operators: and, or, not", "checks whether an element is in an object")
kable(
  data_frame(symbol = operators, name = explanation), 
  caption = "Table of comparison operators that result in boolean (TRUE/FALSE) outputs.", 
  booktabs = TRUE)
```

#### The pipe operator `%>%` 

<!-- mention that it's similar to the + operation in ggplot -->

```{r pipe, echo=FALSE, fig.cap="Inspiration for the `magrittr` package name."}
  include_graphics("figures/images/pipe.jpg")
```

The pipe operator `%>%` is a special operator introduced in the `magrittr` package. It is used heavily in the tidyverse. The basic idea is simple: this operator allows us to "pipe" several functions into one long chain. 


The logic is the following: 

```{r}
a = 3
b = 4
sum(a, b) #standard way 
a %>% sum(b) #the pipe way 
```

The pipe operator inserts the result of one computation as a first element into the next computation. So, `a %>% sum(b)` is equivalent to `sum(a, b)`. We can also specify to insert the result at a different position via the `.` operator. For example:  

```{r}
a = 10
b = 1 
a %>% seq(from = b, to = .)
```

Here, I used the `.` operator to specify that I woud like to insert the result of `a` where I've put the `.` in the `seq()` function. So far, the pipe operator may not seem particularly useful. One of the great features of the operator though is that it allows us to write code in an intuitive way that fits the order in which we would like to do stuff. 

For example, consider that we want to calculate the root mean squared error between data and prediction. In base R, we would do the following. 

```{r}
data = c(1, 3, 4, 2, 5)
prediction = c(1, 2, 2, 1, 4)
# calculate root mean squared error
rmse = sqrt(mean((data-prediction)^2))
print(rmse)
```

Using the pipe operator, makes the operation more intuitive: 

```{r}
data = c(1, 3, 4, 2, 5)
prediction = c(1, 2, 2, 1, 4)
# calculate root mean squared error
rmse = (data-prediction)^2 %>% #  first we calculate the squared difference 
  mean() %>% # then we take the mean
  sqrt() %>% # and then the square root
  print()
```

First, we calculate the squared error, then we take the mean, and then the square root. The pipe operator `%>%` is similar to the `+` used in `ggplot2`. It allows us to take step-by-step actions in 

### Control flow 

#### if-then {#if-else}

```{r}
number = 3
if(number == 1){
  print("The number is 1.")
}else if (number == 2){
  print("The number is 2.")
}else{
  print("The number is neither 1 nor 2.")
}
```

#### for loop

```{r}

sequence = 1:10

for(i in 1:length(sequence)){
  print(i)
}
```

#### while loop 

```{r}
number = 1 

while(number <= 10){
  print(number)
  number = number + 1
}

```

### Functions 

```{r}
fun_addition = function(a, b){
  x = a + b
  return(str_c("The result is ", x))
}

fun_addition(1,2)

```

<!-- maybe introduce `str_c()` directly instead of `paste0()`? -->

I've used the `paste0()` function here to concatenate the string with the number. (R converts the number `x` into a string for us.) Note, R functions can only return a single object. However, this object can be a list (which can contain anything). 

#### Some often used functions 

```{r frequent-functions}
name = c(
"`length()`",
"`dim()`",
"`rm()  `",
"`seq()`",
"`rep()`",
"`max()`",
"`min()`",
"`which.max()`",
"`which.min()`",
"`mean()`",
"`median()`",
"`sum()`",
"`var()`",
"`sd()`"
)
description = c(
"length of an object",
"dimensions of an object (e.g. number of rows and columns)",
"remove an object",
"generate a sequence of numbers",
"repeat something n times",
"maximum",
"minimum",
"index of the maximum",
"index of the maximum",
"mean",
"median",
"sum",
"variance",
"standard deviation"
)
kable(x = tibble(name, description), 
      caption = "Some frequently used functions.", 
      align = c("r", "l"),
      booktabs = TRUE)
```



### Looking at data

The package `dplyr` which we loaded as part of the tidyverse, includes a data set with information about starwars characters. Let's store this as  `df.starwars`. 

```{r}
df.starwars = starwars
```

> Note: Unlike in other languages (such as Python or Matlab), a `.` in a variable name has no special meaning and can just be used as part of the name. I've used `df` here to indicate for myself that this variable is a data frame. 

There are several ways of taking a look at data in R. Personally, I like to look at the data within RStudio's data viewer. To do so, you can: 
- click on the `df.starwars` variable in the "Environment" tab  
- type `View(df.starwars)` in the console 
- move your mouse over (or select) the variable in the editor (or console) and hit `F2` 

I like the `F2` route the best as it's fast and flexible. 

Sometimes it's also helpful to look at data in the console instead of the data viewer. Particularly when the data is very large, the data viewer can be sluggish. 

Here are some useful functions: 

```{r}
head(df.starwars)
```

`head()` only shows the top six rows of the data. 

```{r}
glimpse(df.starwars)
```

`glimpse()` is helpful when the data frame has many columns. The data is shown in a transposed way with columns as rows. 

```{r}
df.starwars %>% 
  distinct(name)
```

`distinct()` shows all the distinct values for a character or factor column. 

```{r}
df.starwars %>% 
  count(gender)
```

`count()` shows a count of all the different distinct values in a column. 

It's possible to do grouped counts by combining several variables.

```{r}
df.starwars %>% 
  count(species, gender) %>% 
  head(n = 10)
```

By default, `count()` results in a data frame that only lists combinations that actually exist. If you'd like to have all the values, the following code will do: 

```{r}
df.starwars %>% 
  count(species, gender) %>%
  complete(species, gender, fill = list(n = 0)) %>% 
  head(n = 10)
```

Here, I've used the `complete()` function to generate all the combinations of `species` and `gender`, and told the function to fill in the value 0 for those combinations that don't exist.  

You can also add counts to a data frame. 

```{r}
df.starwars %>% 
  add_count(species) %>% 
  head()
```

#### Other tools for taking a quick look at data 


```{r}
library("visdat")
visdat::vis_dat(df.starwars)
```

The `vis_dat()` function from the `visdat` package, gives a visuall summary that makes it easy to see the variable types and whether there are missing values in the data. 

```{r}
# library("skimr")
skimr::skim(df.starwars)
```

The `skim()` function from the `skimr` package provides a nice overview of the data, separated by variable types. 

Once we've taken a look at the data this way, the next step is to visualize relationships between variables of interest (like we've learned in the visualization chapter). 

### A quick note on naming things 

Personally, I like to name things in a (pretty) consistent way so that I have no trouble finding stuff even when I open up a project that I haven't worked on for a while. I try to use the following naming conventions: 

```{r}
name = c(
  "df.thing",
  "l.thing",
  "fun.thing",
  "tmp.thing")
use = c(
  "for data frames",
  "for lists",
  "for functions",
  "for temporary variables"
  )
kable(x = tibble(name, use), 
      caption = "Some naming conventions I adopt to make my life easier.", 
      align = c("r", "l"),
      booktabs = TRUE)

```

## Wrangling data 

We use the functions in the package `dplyr` to manipulate our data. 

### filter() 

```{r}
df.starwars %>% 
  filter(gender == 'male',
    height > median(height, na.rm = T),
    !is.na(mass)) %>% 
  head()
```

`filter()` lets us apply logical operators (see Table \@ref(tab:operators)) to subset the data. Here, we filtered out the male characters whose height is greater than the median height (i.e. in the top 50 percentile), and whose mass was not `NA`. Many functions like `mean()`, `median()`, `var()`, `sd()`, `sum()` have the argument `na.rm` which is set to `FALSE` by default. I set the argument to `TRUE` here (or `T` for short), which means that the `NA` values are ignored, and the `median()` is calculated based on the remaning values.

You can use `,` and `&` interchangeably in `filter()`. Make sure to use parentheses when using several logical operators to indicate which logical operation should be performed first: 

```{r}
df.starwars %>% 
  filter((skin_color %in% c("dark", "pale") | gender == "hermaphrodite") & height > 170)
```

So here we have it. The starwars characters that have either a `"dark"` or a `"pale"` skin tone, or whose gender is `"hermaphrodite"`, and whose height is at least `170` cm. The `%in%` operator is useful when there are multiple options. Instead of `skin_color %in% c("dark", "pale")`, I could have also written `skin_color == "dark" | skin_color == "pale"` but this gets cumbersome as the options increase. 


<!-- maybe mention `near()`, `between()`, `any_vars()` -->


### rename() 

`rename()` renames column names.

```{r}
df.starwars %>% 
  rename(person = name,
         mass_kg = mass) %>% 
  head()
```

To rename many variables at the same time use `set_names()`: 

```{r}
df.starwars %>% 
  set_names(letters[1:ncol(.)]) %>% #renamed all variables to letters: a, b, ...
  head()
```


### select() 

`select()` allows us to select a subset of the columns in the data frame. 

```{r}
df.starwars %>% 
  select(name, height, mass) %>% 
  head()
```

We can select multiple columns using the `(from:to)` syntax: 

```{r}
df.starwars %>%  
  select(name:birth_year) %>%  #from name to birth_year
  head()
```

Or use a variable for column selection: 

```{r}
columns = c("name", "height", "species")
df.starwars %>% 
  select(one_of(columns)) %>% #useful when using a variable for column selection
  head()
```

We can also _deselect_ (multiple) columns:

```{r}
df.starwars %>% 
  select(-name, -(birth_year:vehicles)) %>% 
  head()
```

And select columns by partially matching the column name:


```{r select-helpers}
df.starwars %>% 
  select(contains("_")) %>% #every column that contains the character "_"
  head()

df.starwars %>% 
  select(starts_with("h")) %>% #every column that starts with an "h"
  head()
```

We can also use `select()` to reorder the columns: 

```{r}
df.starwars %>% 
  select(eye_color, everything()) %>% #useful trick for changing the column order, now eye_color and birth_year are at the beginning
  head()
```

Here, I've moved the `eye_color` column to the beginning of the data frame. `everything()` is a helper function which selects all the columns. 

```{r}
df.starwars %>% 
  select(-eye_color, everything(), eye_color) %>% #move eye_color to the end
  head()
```

Here, I've moved `eye_color` to the end. Note that I had to deselect it first. 


We can select columns based on their data type using `select_if()`. 

```{r}
df.starwars %>% 
  select_if(is.numeric) %>% #just select numeric columns
  head()
```

The following selects all columns that are not numeric: 

```{r}
df.starwars %>% 
  select_if(funs(!is.numeric(.))) %>% #selects all columns that are not numeric 
  head()
```

Note that I needed to use the `funs()` helper function here. 

It's also possible to select columns based on logical criteria. For example, this bit of code selects columns whose mean value is greater than 90. 

```{r}
df.starwars %>% 
  select_if(funs(is.numeric(.) & mean(., na.rm = T) > 90)) %>% 
  head()
```


We can rename some of the columns using select like so: 

```{r}
df.starwars %>% 
  select(person = name, height, mass_kg = mass) %>% 
  head()
```

<!-- Or rename all of the columns:  -->

<!-- ```{r} -->
<!-- df.starwars %>%  -->
<!--   select_all(toupper) %>% #change to capital letters -->
<!--   head() -->
<!-- ``` -->


When you have a data frame with row names, you can convert the row names to a separate column using the `rownames_to_column()` function. 

For more details, take a look at the help file for `select()`, and this [this great tutorial](https://suzan.rbind.io/2018/01/dplyr-tutorial-1/) in which I learned about some of the more advanced ways of using `select()`. 


### arrange() 

`arrange()` allows us to sort the values in a data frame by one or more column entries. 

```{r}
df.starwars %>% 
  arrange(gender, desc(height))
```


Here, I've sorted the data frame first by gender, and then by height. I've used the `desc()` function to sort height in descending order. The first entry in the output is now the tallest female starwars character. 

### mutate() 

`mutate()` is used to change exisitng columns or make new ones. 

```{r}
df.starwars %>% 
  mutate(height = height / 100, # to get height in meters
    bmi = mass/(height^2)) %>% #bmi = kg/(m^2)
  select(name, height, mass, bmi) %>% 
  head()
```

Here, I've calculated the bmi for the different starwars characters. I first mutated the height variable by going from cm to m, and then created the new column "bmi".

A useful helper function for `mutate()` is `ifelse()` which is a shorthand for the if-else control flow (Section \@ref(if-else)). Here is an example: 

```{r}
df.starwars %>% 
  mutate(height_categorical = ifelse(height > median(height, na.rm = T), 'tall', 'short')) %>% 
  select(name, contains("height"))
```

`ifelse()` works in the following way: we first specify the condition, then what should be returned if the condition is true, and finally would should be returned otherwise. The more verbose version of the statement above would be: `ifelse(test = height > median(height, na.rm = T), yes = 'tall', no = 'short')` 

There are a number of variants of the `mutate()` function. Let's take a look at them. 

#### mutate_at()

With `mutate_at()`, we can mutate several columns at the same time. 

```{r}
df.starwars %>% 
  mutate_at(vars(height, mass, birth_year), funs(scale))
```

<!-- explain what z-scoring is? -->

`vars()` and `funs()` are helper functions. In `vars()` I've specified what variables to mutate, and in `funs()` I've specified what to do with the variables. Here, I've z-scored `height`, `mass`, and `birth_year` using the `scale()` function. Note that I wrote the function without `()`. The `funs()` helper expects a list of functions that can be specified by: 

- Their name, "mean"
- The function itself, `mean`
- A call to the function with `.` as a dummy argument, `mean(.)`

Within `vars()`, we can use the same helper functions for selecting columns that we've seen in Block \@ref(select-helpers) for `select()`. 

We can also use names to create new columns:

```{r}
df.starwars %>% 
  mutate_at(vars(height, mass, birth_year), funs(z = scale)) %>% 
  select(name, contains("height"), contains("mass"), contains("birth_year"))
```

And we can apply several functions at the same time. 

```{r}
df.starwars %>% 
  mutate_at(vars(height, mass, birth_year), funs(z = scale, centered = scale(., scale = FALSE))) %>% 
  select(name, contains("height"), contains("mass"), contains("birth_year"))
```

Here, I've created z-scored and centered versions of the `height`, `mass`, and `birth_year` columns in one go. 

#### mutate_all()

`mutate_all()` is used to mutate all columns in a data frame.  

```{r}
df.starwars %>% 
  select(height, mass) %>%
  mutate_all(funs(as.character)) #transform all columns to characters
```

Here, I've selected some columns first, and then changed the mode to character in each of them. 

Like we've seen with `mutate_at()`, you can add a name in the `mutate_all()` function call to make new columns instead of replacing the existing ones. 

```{r}
df.starwars %>% 
  select(height, mass) %>%
  mutate_all(funs(char = as.character)) #make new character columns
```


#### mutate_if()

`mutate_if()` can sometimes come in handy. For example, the following code changes all the numeric columns to character columns:


```{r}
df.starwars %>% 
  mutate_if(is.numeric, as.character)
```

Or we can round all the numeric columns: 

```{r}
df.starwars %>% 
  mutate_if(is.numeric, round) %>% 
  head()
```


### group_by() and summarize()

A particularly powerful way of interating with data is by grouping and summarizing it. `summarize()` returns a single value for each summary that we ask for: 

```{r}
df.starwars %>% 
  summarize(height_mean = mean(height, na.rm = T),
            height_max = max(height, na.rm = T),
            n = n())
```

Here, I computed the mean height, the maximum height, and the total number of observations (using the function `n()`). 


Let's say we wanted to get a quick sense for how tall starwars characters from different species are. To do that, we combine grouping with summarizing: 

```{r}
df.starwars %>% 
  group_by(species) %>% 
  summarize(height_mean = mean(height, na.rm = T),
            group_size = n())
```

I've first used `group_by()` to group our data frame by the different species, and then used `summarize()` to calculate the mean height of each species, as well as the size of each group. 

```{r}
df.starwars %>% 
  group_by(species) %>% #group by species
  summarize(height.mean = mean(height, na.rm = T))
```

It would also be useful to know how many observations there are in each group. 

```{r}
df.starwars %>% 
  group_by(species) %>% #group by species
  summarize(height.mean = mean(height, na.rm = T), #calculate mean height
            group.size = n()) %>% #number of observations in each group
  arrange(desc(group.size)) %>% #arrange by group size in descending order 
  na.omit() #remove all rows that contain at least one NA value
```

Here, I've used the `n()` function to get the number of observations in each group, and then I've arranged the data frame according to group size in descending order, and I've removed all the rows that contain at least one missing value via `na.omit()`. So, Humans are the largest group in our data frame, followed by Droids (who are considerably smaller) and Gungans (who would make for good Basketball players). 

Sometimes `group_by()` is also useful without summarising the data. For example, we often want to z-score data on the level of individual participants. To do so, we first group the data on the level of participants, and then use `mutate()` to scale the data. Here is an example: 

```{r}
# generate some random data 
data_frame(
  participant = rep(1:3, each = 5),
  judgment = sample(0:100, size = 15, replace = TRUE)
) %>% 
  group_by(participant) %>% #group by participants
  mutate(judgment_zscored = scale(judgment)) %>% #z-score data on individual participant level 
  ungroup() #ungroup the data frame 
```

First, I've generated some random data using the repeat function `rep()` for making a `participant` column, and the `sample()` function to randomly choose values from a range between 0 and 100 with replacement. I've then grouped the data by participatn, and used the scale function to z-score the data. 


Sometimes, I want to run operations for each row, rather than per column. For example, let's say that I wanted each character's mean of combining hieght ans mass (for some reason). 

Let's see first what doesn't work: 

```{r}
df.starwars %>% 
  mutate(mean_height_mass = mean(c(height, mass), na.rm = T)) %>% 
  select(name, height, mass, mean_height_mass) %>% 
  head()
```

Note that all the values are the same. The value shown here is just the mean of all the values in `height` and `mass`.

```{r}
df.starwars %>% 
  select(height, mass) %>% 
  unlist() %>% #turns the data frame into a vector
  mean(na.rm = T) 
```

To get the mean by row, we can either spell out the arithmetic

```{r}
df.starwars %>% 
  mutate(mean_height_mass = (height + mass) / 2) %>% 
  select(name, height, mass, mean_height_mass) %>% 
  head()
```

of use the `rowwise()` helper function which is like `group_by()` but treats each row like a group: 

```{r}
df.starwars %>% 
  rowwise() %>% 
  mutate(mean_height_mass = mean(c(height, mass), na.rm = T)) %>% 
  select(name, height, mass, mean_height_mass) %>% 
  head()
```


### gather() and spread() 

We want our data frames to be tidy. What's tidy? 

1. Each variable must have its own column.
2. Each observation must have its own row.
3. Each value must have its own cell.

For more information on tidy data frames see the [Tidy data](http://r4ds.had.co.nz/tidy-data.html) chapter in Hadley Wickham's R for Data Science book. 

Let's first generate a data set that is _not_ tidy. 

```{r}
# construct data frame 
df = data_frame(
  participant = c(1, 2),
  observation_1 = c(10, 25),
  observation_2 = c(100, 63),
  observation_3 = c(24, 45)
)

df %>% print()
```

Here, I've generated data from two participants with three observations. This data frame is not tidy since each row contains more than a single observation. We can make it tidy using the `gather()` function. 

```{r}
df.tidy = df %>% 
  gather(key = 'index', value = 'rating', -participant) %>% 
  arrange(participant) %>% 
  print()
```

`df.tidy` now contains one observation in each row. The `gather()` function takes four arguments: 

1. the data which I've passed to it via the pipe `%>%` 
2. a name for the `key` column which will contain the column names of the original data frame
3. a name for the `value` column which will contain the values that were spread across different columns in the original data frame
4. a specification for which columns we want to gather -- here I've specified that we want to gather the values from all columns except the `participant` column

`spread()` is the counterpart of `gather()`. We can use it to go from a data frame that is in long format, to a data frame that's in wide format, like so: 

```{r}
df.wide = df.tidy %>% 
  spread(index, rating) %>% 
  print()
```
For my data, I often have a wide data frame that contains demographic information about participants, and a long data frame that contains participants' responses in the experiment. 

Here is a slightly more advanced example of using `gather()`. Let's consider we have the following data frame: 

```{r}
# construct data frame 
df2 = data_frame(
  participant = c(1, 2),
  stimulus_1 = c('flower', 'car'),
  observation_1 = c(10, 25),
  stimulus_2 = c('house', 'flower'),
  observation_2 = c(100, 63),
  stimulus_3 = c('car', 'house'),
  observation_3 = c(24, 45)
)

df2 %>% print()
```

Now, the data frame contains in each row, which stimuli a participant saw, and what rating she gave. Each of the two participants saw a picture of a flower, car, and house, and rated how much they liked the picture on a scale from 0 to 100. The order at which the pictures were presented was randomized between participants. I will use a combination of `gather()` and `spread()` to turn this into a data frame in long format. 

```{r}
df.tidy2 = df2 %>% 
  gather(key = 'index', value = 'value', -participant) %>% 
  separate(index, into = c('index', 'order'), sep = "_") %>% 
  spread(index,value) %>% 
  mutate(observation = as.numeric(observation)) %>% 
  select(participant, order, stimulus, rating = observation) %>% 
  arrange(participant) %>% 
  print()
```

Voilà! Getting the desired data frame involved a few new tricks. Let's take it step by step. 

First, I use `gather()` to make a long table. 

```{r}
df2 %>% 
  gather(key = 'index', value = 'value', -participant)
  
```

However, I want to have the information about the stimulus and the observation in the same row. That is, I want to see what rating a participant gave to the flower stimulus, for example. To get there, I separate the `index` column into two separate columns using the `separate()` function. In the `separate()` function, I first defined which column I want to separate, and then the column names that I want to separate the original column into. Finally, I specified what separator to use, namely `_` in this case. 


```{r}
df2 %>% 
  gather(key = 'index', value = 'value', -participant) %>%
  separate(index, into = c('index', 'order'), sep = "_")
```

Note, like `gather()` and `spread()`, there is a partner for `separate()`, too. It's called `unite()` and it allows you to combine several columns into one. Now, I can use the `spread()` function to make a separate column for each entry in `index` that contains the values in `value`. 

```{r}
df2 %>% 
  gather(key = 'index', value = 'value', -participant) %>% 
  separate(index, into = c('index', 'order'), sep = "_") %>% 
  spread(index,value)
```

That's pretty much it. Now, each row contains information about the order in which a stimulus was presented, what the stimulus was, and the judgment that a participant made in this trial. 

```{r}
df2 %>% 
  gather(key = 'index', value = 'value', -participant) %>% 
  separate(index, into = c('index', 'order'), sep = "_") %>% 
  spread(index,value) %>% 
  mutate_at(vars(order, observation), funs(as.numeric)) %>% 
  select(participant, order, stimulus, rating = observation) %>% 
  arrange(participant, order)
```

The rest is familiar. I've used `mutate_at()` to turn `order` and `observation` into numeric columns, `select()` to change the order of the columns (and renamed the `observation` column to `rating` along the way), and `arrange()` to sort the data frame by `participant` and `order`. 

Getting familiar with `gather()` and `spread()` takes some time plus trial and error. So don't be discouraged if you don't get what you want straight away. Once you've mastered these functions, they will make easier to beat data frames into the desired shape. After having done some transformations like this, it's worth checking that nothing went wrong. I often compare a few values in the transformed and original data frame to make sure everything is legit. 

<!-- included links to more information about tidy data frames -->

### missing values 

- talk about `complete()` 

### join multiple data frames 

Additional resources: 
- [Two-table verbs](https://dplyr.tidyverse.org/articles/two-table.html)
- [Relational data chapter in R for Data Science](http://r4ds.had.co.nz/relational-data.html)
- [Tutorial by Jenny Bryan](http://stat545.com/bit001_dplyr-cheatsheet.html)
- [Datacamp course on joining tables](https://www.datacamp.com/courses/joining-data-in-r-with-dplyr)

Often information sits in different data frames. For example, I may have one data frame `df.stimuli` with information about each stimulus, and then have another data frame with participants' responses `df.responses` that only contains a stimulus index but not all the information. 

```{r}
set.seed(1) #setting seed to make the example reproducible

# data frame with stimulus information
df.stimuli = data_frame(
  index = 1:5,
  height = runif(n = 5, min = 0, max = 10),
  width = runif(n = 5, min = 0, max = 10),
  n_dots = sample(10:100, size = 5, replace = TRUE),
  color = sample(c("green", "blue", "white", "red"), size = 5, replace = TRUE)
) %>% 
  print()

# data frame with participants' responses
df.responses = data_frame(
  participant = rep(1:3, each = 5),
  index = sample(1:5) %>% rep(3),
  response = sample(0:100, size = 15, replace = TRUE)
) %>% 
  print()

```

The `df.stimuli` data frame contains an `index`, information about the `height`, and `width`, as well as the number of `dots`, and their `color`. Let's imagine that participants had to judge how much they liked each image from a scale of 0 ("not liking this dot pattern at all") to 100 ("super thrilled about this dot pattern"). 

Let's say that I now wanted to know what participants' average response for the differently colored dot patterns are. Here is how I would do this: 

```{r}
df.responses %>% 
  left_join(df.stimuli %>% select(index, color), by = "index") %>% 
  group_by(color) %>% 
  summarise(response.mean = mean(response))
```

Let's take it step by step. The key here is to add the information from the `df.stimuli` data frame to the `df.responses` data frame. 

```{r}
df.responses %>% 
  left_join(df.stimuli %>% select(index, color), by = "index")
```

I've joined the `df.stimuli` table in which I've only selected the `index` and `color` column, with the `df.response` table, and specified the `index` column as the one by which the tables should be joined. 

Sometimes, the tables I want to join don't have any column names in common. In that case, we can tell the `left_join()` function which column pair(s) should be used for joining. 

```{r}
df.responses %>% 
  rename(stimuli = index) %>% #I've renamed the index column to stimuli
  left_join(df.stimuli %>% select(index, color), by = c("stimuli" = "index"))
```

Here, I've first renamed the index column (to create the problem) and then used the `by = c("stimuli" = "index")` construction (to solve the problem). 

We can also join data frames by using multipe columns. In my experience, it often takes a little bit of playing around to make sure that the data frames were joined as intended. One very good indicator is the row number of the initial data frames, and the joined one. For a `left_join()`, most of the time, we want the row number of the original ("the one on the left") and the joined table to be the same. If the row number changed, something probably went wrong. 

Take a look at the `join` help file to see other operations for combining two or more data frames into one (make sure to look at the one from the `dplyr` package). 


## Reading in data 

So far, we've used data that

- make a table with information about the different file formats 

There 

```{r}
file_type = c("`csv`", "`RData`", "`xls`", "`json`", "`feather`")
platform = c(
  "general",
  "R",
  "excel",
  "general",
  "python & R"
)
description = c(
  "medium-size data frames",
  "saving the results of intensive computations",
  "people who use excel",
  "more complex data structures",
  "fast interaction between R and python"
)

kable(data_frame(`file type` = file_type,
                 platform = platform,
                 description = description),
      align = c("r", "l", "l"))
```


The [`foreign` package](https://cran.r-project.org/web/packages/foreign/index.html) helps with importing data that was saved in SPSS, Stata, or Minitab. 


## Saving data 

### csv

### xls

### json

### sav

### feather 

### RData

## Saving data 

### RData 

- useful for saving more complex computations

### csv 

### feather ... 


```{r}
print(sessionInfo(), locale = FALSE)
```
